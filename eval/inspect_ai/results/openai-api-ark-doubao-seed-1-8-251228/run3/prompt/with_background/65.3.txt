PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Write a function that returns the tensor product of an arbitrary number of matrices/vectors.



def tensor(*args):
    '''Takes the tensor product of an arbitrary number of matrices/vectors.
    Input:
    args: any number of nd arrays of floats, corresponding to input matrices
    Output:
    M: the tensor product (kronecker product) of input matrices, 2d array of floats
    '''
    if not args:
        raise ValueError("At least one matrix or vector must be provided.")
    
    # Convert 1D inputs to 2D column vectors and validate input dimensions
    processed = []
    for arg in args:
        if arg.ndim == 1:
            processed.append(arg.reshape(-1, 1))
        elif arg.ndim == 2:
            processed.append(arg)
        else:
            raise ValueError("All inputs must be 1D vectors or 2D matrices.")
    
    # Compute iterative Kronecker product leveraging associativity
    result = processed[0]
    for mat in processed[1:]:
        result = np.kron(result, mat)
    
    return result


------

Write a function that applies the Kraus operators of a quantum channel on subsystems of a state with tensor function. If sys and dim are given as None, then the channel acts on the entire system of the state rho. If sys is given as a list, then the channel is applied to each subsystem in that list, and the dimension of each subsystem also must be given.
Background
The action of quantum channels can be written in terms of its Kraus representation:
$$ \mathcal{N}(\rho) = \sum_i K_i \rho K_i^\dagger $$
where $\sum_i K_i^\dagger K_i = \mathbb{I}$. The $K_i$'s are called the Kraus operators of the channel $\mathcal{N}$. If the quantum channel acts on the $i$-th subsystem of $\rho$, then the Kraus operators has the form $\mathbb{I}\otimes\cdots\otimes\mathbb{I}\otimes K_i\otimes\mathbb{I}\otimes\cdots\otimes\mathbb{I}$, where $K_i$ acts on the $i$-th subsystem and the identity acts on the remaining systems.


def apply_channel(K, rho, sys=None, dim=None):
    '''Applies the channel with Kraus operators in K to the state rho on
    systems specified by the list sys. The dimensions of the subsystems of
    rho are given by dim.
    Inputs:
    K: list of 2d array of floats, list of Kraus operators
    rho: 2d array of floats, input density matrix
    sys: list of int or None, list of subsystems to apply the channel, None means full system
    dim: list of int or None, list of dimensions of each subsystem, None means full system
    Output:
    matrix: output density matrix of floats
    '''
    # Validate rho is a square 2D matrix
    if rho.ndim != 2 or rho.shape[0] != rho.shape[1]:
        raise ValueError("rho must be a square 2D matrix.")
    
    # Validate Kraus operators
    if not isinstance(K, list) or len(K) == 0:
        raise ValueError("K must be a non-empty list of Kraus operators.")
    k_dim = None
    for ki in K:
        if ki.ndim != 2 or ki.shape[0] != ki.shape[1]:
            raise ValueError("All Kraus operators must be square 2D matrices.")
        if k_dim is None:
            k_dim = ki.shape[0]
        else:
            if ki.shape[0] != k_dim:
                raise ValueError("All Kraus operators must have the same dimensions.")
    
    # Validate sys and dim consistency
    if (sys is None) != (dim is None):
        raise ValueError("sys and dim must both be None or both be lists.")
    
    # Case 1: Channel acts on entire system
    if sys is None and dim is None:
        if k_dim != rho.shape[0]:
            raise ValueError("Kraus operators must match the dimension of rho when acting on the entire system.")
        result = np.zeros_like(rho, dtype=complex)
        for ki in K:
            result += ki @ rho @ ki.conj().T
        return result
    
    # Case 2: Channel acts on specified subsystems
    else:
        # Validate sys is a list of integers
        if not isinstance(sys, list) or not all(isinstance(s, int) for s in sys):
            raise ValueError("sys must be a list of integers.")
        # Validate dim is a list of positive integers
        if not isinstance(dim, list) or not all(isinstance(d, int) and d > 0 for d in dim):
            raise ValueError("dim must be a list of positive integers.")
        
        # Check subsystem dimensions product matches rho's dimension
        total_dim = np.prod(dim)
        if total_dim != rho.shape[0]:
            raise ValueError(f"Product of subsystem dimensions ({total_dim}) does not match rho's dimension ({rho.shape[0]}).")
        
        # Validate subsystem indices are within range
        num_subsystems = len(dim)
        for s in sys:
            if s < 0 or s >= num_subsystems:
                raise ValueError(f"Subsystem index {s} is out of range. Must be between 0 and {num_subsystems - 1}.")
        
        # Validate target subsystems match Kraus operator dimension
        for s in sys:
            if dim[s] != k_dim:
                raise ValueError(f"Subsystem {s} has dimension {dim[s]}, but Kraus operators are {k_dim}x{k_dim}.")
        
        # Precompute identity matrices for each subsystem
        id_list = [np.eye(d, dtype=rho.dtype) for d in dim]
        
        # Generate all combinations of Kraus operators for each target subsystem
        kraus_tuples = itertools.product(K, repeat=len(sys))
        
        # Initialize result matrix
        result = np.zeros_like(rho, dtype=complex)
        
        # Iterate over all Kraus operator combinations
        for tpl in kraus_tuples:
            op_list = []
            for subsystem_idx in range(num_subsystems):
                # Collect all Kraus operators acting on current subsystem
                relevant_kraus = [tpl[i] for i in range(len(sys)) if sys[i] == subsystem_idx]
                
                if not relevant_kraus:
                    # No channel action: use identity
                    op = id_list[subsystem_idx]
                else:
                    # Compute product of Kraus operators in reverse application order
                    reversed_ops = reversed(relevant_kraus)
                    op = next(reversed_ops)
                    for mat in reversed_ops:
                        op = op @ mat
                
                op_list.append(op)
            
            # Compute full operator via tensor product
            full_op = tensor(*op_list)
            # Add the contribution of this Kraus operator combination
            result += full_op @ rho @ full_op.conj().T
        
        return result


NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Given a 2n-qubit input state and the Kraus operators of two qubit channels channel1 and channel2, we send the first n qubits through n uses of channel1 and the last n qubits through n uses of channel2. Implement a function that returns the output state using the apply_channel function in . Here, channel2 is set to None in default, and if channel2 is None, it is set to be equal to channel1.


def channel_output(input_state, channel1, channel2=None):
    '''Returns the channel output
    Inputs:
        input_state: density matrix of the input 2n qubit state, ( 2**(2n), 2**(2n) ) array of floats
        channel1: kruas operators of the first channel, list of (2,2) array of floats
        channel2: kruas operators of the second channel, list of (2,2) array of floats
    Output:
        output: the channel output, ( 2**(2n), 2**(2n) ) array of floats
    '''

    return output

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

import numpy as np
from scipy.linalg import sqrtm
import itertools

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.