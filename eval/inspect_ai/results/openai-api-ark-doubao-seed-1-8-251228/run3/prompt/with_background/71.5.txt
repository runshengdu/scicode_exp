PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Given integers $j$ and $d$, write a function that returns a standard basis vector $|j\rangle$ in $d$-dimensional space. If $d$ is given as an int and $j$ is given as a list $[j_1,j_2\cdots,j_n]$, then return the tensor product $|j_1\rangle|j_2\rangle\cdots|j_n\rangle$ of $d$-dimensional basis vectors. If $d$ is also given as a list $[d_1,d_2,\cdots,d_n]$, return $|j_1\rangle|j_2\rangle\cdots|j_n\rangle$ as tensor product of $d_1$, $d_2$, ..., and $d_n$ dimensional basis vectors.
Background
A standard basis vector $|j\rangle$ in $d$ dimensional space is
\begin{pmatrix} 0 \\ 0 \\ \vdots \\ 1 \\ \vdots \\ 0 \end{pmatrix}
with a 1 on the $j$-th position and 0's everywhere else. Tensor products of two vectors are given by the Kronecker product 
\begin{align}
|a\rangle|b\rangle = \begin{pmatrix} a_1 \\ a_2 \\ \vdots \\ a_n \end{pmatrix} \otimes \begin{pmatrix} b_1 \\ b_2 \\ \vdots \\ b_n \end{pmatrix} = \begin{pmatrix} a_1b_1 \\ a_1b_2 \\ \vdots \\ a_1b_n \\ a_2b_1 \\ a_2b_2 \\ \vdots \\ a_2b_n \\ a_nb_1 \\ a_nb_2 \vdots \\ a_nb_n \end{pmatrix}
\end{align}


def ket(dim, j):
    '''Input:
    dim: int or list, dimension(s) of the ket(s)
    j: int or list, the index(es) of the basis vector(s)
    Output:
    out: array of float, the matrix representation of the ket or tensor product of kets
    '''
    def _single_ket(d, idx):
        vec = np.zeros(d, dtype=float)
        vec[idx] = 1.0
        return vec
    
    # Case 1: Single basis vector (dim is int, j is int)
    if isinstance(dim, int) and isinstance(j, int):
        return _single_ket(dim, j)
    
    # Case 2: Tensor product of multiple kets with same dimension (dim is int, j is list)
    elif isinstance(dim, int) and isinstance(j, list):
        if not all(isinstance(idx, int) for idx in j):
            raise TypeError("All elements in j must be integers when dim is an integer")
        kets = [_single_ket(dim, idx) for idx in j]
        result = kets[0]
        for vec in kets[1:]:
            result = np.kron(result, vec)
        return result
    
    # Case 3: Tensor product of kets with different dimensions (dim is list, j is list)
    elif isinstance(dim, list) and isinstance(j, list):
        if len(dim) != len(j):
            raise ValueError("dim and j must have the same length when both are lists")
        if not all(isinstance(d, int) for d in dim):
            raise TypeError("All elements in dim must be integers")
        if not all(isinstance(idx, int) for idx in j):
            raise TypeError("All elements in j must be integers")
        kets = [_single_ket(d, idx) for d, idx in zip(dim, j)]
        result = kets[0]
        for vec in kets[1:]:
            result = np.kron(result, vec)
        return result
    
    # Invalid input combinations
    else:
        raise TypeError(
            "Invalid input combination: "
            "dim must be int or list; "
            "if dim is int, j can be int or list; "
            "if dim is list, j must be list of same length"
        )


------

Write a function that returns the tensor product of an arbitrary number of matrices/vectors.



def tensor(*args):
    '''Takes the tensor product of an arbitrary number of matrices/vectors.
    Input:
    args: any number of nd arrays of floats, corresponding to input matrices
    Output:
    M: the tensor product (kronecker product) of input matrices, 2d array of floats
    '''
    processed = []
    for arg in args:
        arr = np.asarray(arg)
        if arr.ndim not in (1, 2):
            raise ValueError("All inputs must be 1D (vectors) or 2D (matrices)")
        arr = arr.astype(float)
        if arr.ndim == 1:
            arr = arr.reshape(-1, 1)
        processed.append(arr)
    
    if not processed:
        return np.array([[1.0]], dtype=float)
    
    result = processed[0]
    for mat in processed[1:]:
        result = np.kron(result, mat)
    
    return result


------

Write a function that applies the Kraus operators of a quantum channel on a subsystem of a state with tensor function. If sys and dim are given as None, then the channel acts on the entire system of the state rho. The dimension of each subsystem of the state is also given as an input.
Background
The action of quantum channels can be written in terms of its Kraus representation:
$$ \mathcal{N}(\rho) = \sum_i K_i \rho K_i^\dagger $$
where $\sum_i K_i^\dagger K_i = \mathbb{I}$. The $K_i$'s are called the Kraus operators of the channel $\mathcal{N}$. If the quantum channel acts on the $i$-th subsystem of $\rho$, then the Kraus operators has the form $\mathbb{I}\otimes\cdots\otimes\mathbb{I}\otimes K_i\otimes\mathbb{I}\otimes\cdots\otimes\mathbb{I}$, where $K_i$ acts on the $i$-th subsystem and the identity acts on the remaining systems.



def apply_channel(K, rho, sys=None, dim=None):
    '''Applies the channel with Kraus operators in K to the state rho on
    systems specified by the list sys. The dimensions of the subsystems of
    rho are given by dim.
    Inputs:
    K: list of 2d array of floats, list of Kraus operators
    rho: 2d array of floats, input density matrix
    sys: list of int or None, list of subsystems to apply the channel, None means full system
    dim: list of int or None, list of dimensions of each subsystem, None means full system
    Output:
    matrix: output density matrix of floats
    '''
    # Validate rho is square
    if rho.shape[0] != rho.shape[1]:
        raise ValueError("rho must be a square matrix")
    
    # Validate K is list of 2D square arrays
    if not isinstance(K, list) or any(not isinstance(k, np.ndarray) or k.ndim != 2 or k.shape[0] != k.shape[1] for k in K):
        raise ValueError("K must be a list of 2D square numpy arrays")
    
    d_full = rho.shape[0]
    
    # Case 1: Channel acts on entire system (sys is None)
    if sys is None:
        # Check all Kraus operators are full dimension
        for k in K:
            if k.shape != (d_full, d_full):
                raise ValueError(f"All Kraus operators must be {d_full}x{d_full} when sys is None")
        # Compute channel action
        result = np.zeros_like(rho, dtype=float)
        for k in K:
            result += k @ rho @ k.conj().T
        return result
    
    # Case 2: Channel acts on specified subsystems (sys is not None)
    # Validate dim is provided and valid
    if dim is None:
        raise ValueError("dim must be provided when sys is not None")
    if not isinstance(dim, list) or any(not isinstance(d, int) or d <= 0 for d in dim):
        raise ValueError("dim must be a list of positive integers")
    
    # Helper function to compute product of a list
    def product(lst):
        p = 1
        for x in lst:
            p *= x
        return p
    
    # Check product of dim equals full dimension
    if product(dim) != d_full:
        raise ValueError(f"Product of dimensions in dim ({product(dim)}) must equal the dimension of rho ({d_full})")
    
    # Validate sys is valid
    if not isinstance(sys, list) or any(not isinstance(s, int) for s in sys):
        raise ValueError("sys must be a list of integers")
    n_subsys = len(dim)
    for s in sys:
        if s < 0 or s >= n_subsys:
            raise ValueError(f"Subsystem index {s} is out of bounds (0 to {n_subsys - 1})")
    if len(set(sys)) != len(sys):
        raise ValueError("sys must contain unique subsystem indices")
    
    # Check Kraus operators have correct dimension for the subsystems
    D_sys = product(dim[s] for s in sys)
    for k in K:
        if k.shape != (D_sys, D_sys):
            raise ValueError(f"All Kraus operators must be {D_sys}x{D_sys} for subsystems {sys}")
    
    # Prepare permutation of subsystems to bring sys to front
    all_subsys = list(range(n_subsys))
    non_sys = [s for s in all_subsys if s not in sys]
    perm = sys + non_sys
    perm_dim = [dim[s] for s in perm]
    
    # Helper function to compute index of a tuple in the tensor product basis
    def get_index(tup, dim_list):
        idx = 0
        mult = 1
        # Iterate from last subsystem to first (little-endian order)
        for i in reversed(range(len(dim_list))):
            idx += tup[i] * mult
            mult *= dim_list[i]
        return idx
    
    # Construct permutation matrix P
    P = np.zeros((d_full, d_full), dtype=float)
    # Generate all possible index tuples for the original system
    all_tuples = list(itertools.product(*[range(d) for d in dim]))
    for t in all_tuples:
        old_idx = get_index(t, dim)
        # Permute the tuple to match the permuted subsystem order
        t_perm = tuple(t[s] for s in perm)
        new_idx = get_index(t_perm, perm_dim)
        P[new_idx, old_idx] = 1.0
    
    # Compute identity on non-sys subsystems
    D_non_sys = product(dim[s] for s in non_sys)
    identity_non_sys = np.eye(D_non_sys, dtype=float)
    
    # Compute channel action
    result = np.zeros_like(rho, dtype=float)
    for k in K:
        # Construct Kraus operator on permuted system: k âŠ— identity_non_sys
        k_perm = tensor(k, identity_non_sys)
        # Transform back to original system to get full Kraus operator
        k_full = P.T @ k_perm @ P
        # Add the contribution to the result
        result += k_full @ rho @ k_full.conj().T
    
    return result


------

Permute the subsystems of a state according to the order specified by perm given as a list. The dimensions of subsystems are given as a list of integers.




def syspermute(X, perm, dim):
    '''Permutes order of subsystems in the multipartite operator X.
    Inputs:
    X: 2d array of floats with equal dimensions, the density matrix of the state
    perm: list of int containing the desired order
    dim: list of int containing the dimensions of all subsystems.
    Output:
    Y: 2d array of floats with equal dimensions, the density matrix of the permuted state
    '''
    # Input validations
    if X.shape[0] != X.shape[1]:
        raise ValueError("X must be a square matrix")
    
    if not isinstance(dim, list) or any(not isinstance(d, int) or d <= 0 for d in dim):
        raise ValueError("dim must be a list of positive integers")
    
    # Compute total dimension
    D = 1
    for d in dim:
        D *= d
    
    if D != X.shape[0]:
        raise ValueError(f"Product of dimensions in dim ({D}) must equal the dimension of X ({X.shape[0]})")
    
    if not isinstance(perm, list) or any(not isinstance(s, int) for s in perm):
        raise ValueError("perm must be a list of integers")
    
    if len(perm) != len(dim):
        raise ValueError("perm must have the same length as dim")
    
    if sorted(perm) != list(range(len(dim))):
        raise ValueError(f"perm must be a permutation of 0 to {len(dim)-1}.")
    
    n = len(dim)
    
    # Reshape X into 2n-dimensional array where first n axes are bra indices, last n are ket indices
    X_reshaped = X.reshape(dim + dim)
    
    # Create axis permutation: permute both bra and ket axes according to the given permutation
    bra_perm = perm
    ket_perm = [n + s for s in perm]
    new_axes = bra_perm + ket_perm
    
    # Transpose the array to permute the subsystems
    X_transposed = X_reshaped.transpose(new_axes)
    
    # Reshape back to a D x D matrix
    Y = X_transposed.reshape((D, D))
    
    return Y


NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Calculate the partial trace of a state, tracing out a list of subsystems. Dimensions of all subsystems are given as inputs. Use the syspermute function.
Background
Suppose a state consists of two subsystems of dimension $d_1$ and $d_2$ and has the form 
$$
\begin{pmatrix}
A_{11} & A_{12} & \cdots & A_{1d_1} \\
A_{21} & A_{22} & \cdots & A_{2d_1} \\
\vdots & \vdots & \ddots & \vdots \\
A_{d_11} & A_{d_12} & \cdots & A_{d_1d_1}
\end{pmatrix}
$$
where each $A_{ij}$ is a $d_2\times d_2$ dimensional matrix. Then tracing out the second subsystem gives us
$$
\begin{pmatrix}
\text{tr}A_{11} & \text{tr}A_{12} & \cdots & \text{tr}A_{1d_1} \\
\text{tr}A_{21} & \text{tr}A_{22} & \cdots & \text{tr}A_{2d_1} \\
\vdots & \vdots & \ddots & \vdots \\
\text{tr}A_{d_11} & \text{tr}A_{d_12} & \cdots & \text{tr}A_{d_1d_1}
\end{pmatrix}
$$


def partial_trace(X, sys, dim):
    '''Inputs:
    X: 2d array of floats with equal dimensions, the density matrix of the state
    sys: list of int containing systems over which to take the partial trace (i.e., the systems to discard).
    dim: list of int containing dimensions of all subsystems.
    Output:
    2d array of floats with equal dimensions, density matrix after partial trace.
    '''

        return X

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

import numpy as np 
from scipy.optimize import fminbound
import itertools
from scipy.linalg import logm

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.