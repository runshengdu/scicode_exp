PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Write a function to define simple 1d linear element shape function. When etype equals to 1, it returns $\omega^1(x)$, when the type equals to 2, it returns the value of function $\omega^2(x)$ where
\begin{equation}
\begin{aligned}
\omega_i^1(x) = \frac{x-x_{i-1}}{h_{i-1}} &, \quad \quad x_{i-1} \leq x \leq x_{i}\\
\omega_i^2(x) = \frac{x_{i+1}-x}{h_i}&, \quad \quad x_i\leq x \leq x_{i+1}\\
\end{aligned}
\end{equation}
Background:
The shape function of a simplest linear element is defined as following:
\begin{equation}
\begin{aligned}
\omega_i^1(x) = \frac{x-x_{i-1}}{h_{i-1}} &, \quad \quad x_{i-1} \leq x \leq x_{i}\\
\omega_i^2(x) = \frac{x_{i+1}-x}{h_i}&, \quad \quad x_i\leq x \leq x_{i+1}\\
N(x) = 0&, \quad \quad \text{otherwise}
\end{aligned}
\end{equation}
Hence the basis function evaluated at the interior element i is
\begin{equation}
\omega_i = \omega_i^1(x) + \omega_i^2(x)
\end{equation}
wheras for the boundary nodes $i=1,n+1$ we have
\begin{equation}
\begin{aligned}
\omega_1(x) &= \omega_1^2(x) =  \frac{x_2-x}{h_1}\\
\omega_{n+1} &= \omega_{n+1}^1(x) = \frac{x-x_n}{h_n}
\end{aligned}
\end{equation}
Now write a function respresenting such simple linear element,
which takes five inputs 
- The index of element i.
- An array containing coordinates of nodal degree of freedom (mesh)
- An integer of the total number of the nodal degree of freedom
- An real number of element size
- An integer serving as a indicator, which indicates the type of basis function. When type equals to 1, 
it returns $\omega^1(x)$, when the type equals to 2, it returns the value of function $\omega^2(x)$.



def basis(i, p, M, h, etype):
    '''Inputs
    i: int, the index of node (1-based)
    p: array of arbitrary size 1,2, or 3, the coordinates to evaluate
    M: int, the total number of the nodal dofs
    h: int, the element size
    etype: int, basis function type; When type equals to 1, 
    it returns $\omega^1(x)$, when the type equals to 2, it returns the value of function $\omega^2(x)$.
    Outputs
    v: array of size 1,2, or 3, value of basis function
    '''
    v = np.zeros_like(p, dtype=np.float64)
    x_nodes = np.arange(M) * h  # Nodes are at 0, h, 2h, ..., (M-1)h
    
    if etype == 1:
        # Compute ω_i^1(x)
        if i == 1:
            # Boundary node, no left element, always 0
            pass
        else:
            x_prev = x_nodes[i-2]  # x_{i-1}
            x_curr = x_nodes[i-1]  # x_i
            mask = (p >= x_prev) & (p <= x_curr)
            v[mask] = (p[mask] - x_prev) / h
    elif etype == 2:
        # Compute ω_i^2(x)
        if i == M:
            # Boundary node, no right element, always 0
            pass
        else:
            x_curr = x_nodes[i-1]  # x_i
            x_next = x_nodes[i]    # x_{i+1}
            mask = (p >= x_curr) & (p <= x_next)
            v[mask] = (x_next - p[mask]) / h
    
    return v


------

Write a function to assemble mass matrix A and right hand side vector. Using third order guass quadrature numerical integral scheme. Using supg term as stabilization.
Background:

Mass matrix A:
Mass matrix A is calculated based on the weak form defined above:
\begin{equation}
\int_0^1 \omega_{,x}(-au+\kappa u_{,x})dx
\end{equation}
The problem is discretized with finite element. We use same function 
space for test and trial space.
\begin{equation}
\int_{x_i}^{x_i+1} \omega_{i,x}(-au_{h}+\kappa u_{h,x})dx 
\end{equation}
where u is approximated with the same shape function $\omega$.
\begin{equation}
u_h = c_1 \omega_{i}^1 + c_2 \omega_{i}^2
\end{equation}
Such integral is approximated using gaussian quadrature
\begin{equation}
\sum_{g} w_g * \omega_{,x}(x_g)(-au_{h}(x_g) + \kappa u_{h,x}(x_g) )
\end{equation}

Right hand side vector b:
Right hand side b is calculated as following:
\begin{equation}
\int_0^1 12x^2\omega dx
\end{equation}
Such integral is approximated using gaussian quadrature as well.

Gauess quadrature rules:
Gauess quadrature is utilized to approximate the inner product.
We uses three point gauess quadrature rules here in the computation:
    
- points $[-\frac{3}{5},0,\frac{3}{5}]$
- weights $[\frac{5}{9},\frac{8}{9},\frac{5}{9}]$

The mapped gauess quadrature rules is:
\begin{equation}
\int_{a}^{b} f \approx \frac{b-a}{2} \sum_{i}w_i * f(\frac{b-a}{2}\xi_i + \frac{a+b}{2})
\end{equation}

Define Gauess quadrature map with lambda function
This lambda function mappes from physical points to gauess points.
\begin{equation}
x_i = \frac{x_2-x_1}{2}\xi_i + \frac{x_1+x_2}{2}
\end{equation}


def assemble(M):
    '''Inputs:
    M : number of grid, integer
    Outputs:
    A: mass matrix, 2d array size M*M
    b: right hand side vector , 1d array size M*1
    '''
    if M == 1:
        A = np.zeros((1, 1), dtype=np.float64)
        b = np.zeros((1, 1), dtype=np.float64)
        return A, b
    
    # Element size for domain [0, 1]
    h = 1.0 / (M - 1)
    # Third-order Gauss quadrature points and weights
    gauss_xi = np.array([-3/5, 0, 3/5], dtype=np.float64)
    gauss_w = np.array([5/9, 8/9, 5/9], dtype=np.float64)
    # Coefficients from the weak form (advection and diffusion)
    a = 1.0
    kappa = 1.0
    
    # Initialize global matrix and right-hand side vector
    A = np.zeros((M, M), dtype=np.float64)
    b = np.zeros((M, 1), dtype=np.float64)
    
    # Iterate over each element (0-based index)
    for e in range(M - 1):
        x_e = e * h          # Left boundary of current element
        x_e1 = (e + 1) * h   # Right boundary of current element
        
        # Compute local stiffness matrix using Gauss quadrature
        local_K = np.zeros((2, 2), dtype=np.float64)
        for xi, w in zip(gauss_xi, gauss_w):
            # Map reference coordinate to physical coordinate
            x_g = (x_e1 - x_e) / 2 * xi + (x_e + x_e1) / 2
            # Derivatives of local basis functions (constant over element)
            dN0_dx = -1.0 / h
            dN1_dx = 1.0 / h
            # Local basis function values at Gauss point
            N0 = (x_e1 - x_g) / h
            N1 = (x_g - x_e) / h
            # Derivatives of local basis functions (constant values)
            dN0_dx_val = -1.0 / h
            dN1_dx_val = 1.0 / h
            
            # Calculate integrand terms for each local matrix entry
            term_K00 = dN0_dx * (-a * N0 + kappa * dN0_dx_val)
            term_K01 = dN0_dx * (-a * N1 + kappa * dN1_dx_val)
            term_K10 = dN1_dx * (-a * N0 + kappa * dN0_dx_val)
            term_K11 = dN1_dx * (-a * N1 + kappa * dN1_dx_val)
            
            # Weighted contribution from current Gauss point
            weight = (x_e1 - x_e) / 2 * w
            local_K[0, 0] += weight * term_K00
            local_K[0, 1] += weight * term_K01
            local_K[1, 0] += weight * term_K10
            local_K[1, 1] += weight * term_K11
        
        # Accumulate local matrix into global matrix
        A[e:e+2, e:e+2] += local_K
        
        # Compute local contributions to right-hand side using Gauss quadrature
        b0 = 0.0  # Contribution to left node of element
        b1 = 0.0  # Contribution to right node of element
        for xi, w in zip(gauss_xi, gauss_w):
            x_g = (x_e1 - x_e) / 2 * xi + (x_e + x_e1) / 2
            # Local basis function values at Gauss point
            N0 = (x_e1 - x_g) / h
            N1 = (x_g - x_e) / h
            # Integrand for right-hand side
            integrand_b0 = 12 * (x_g ** 2) * N0
            integrand_b1 = 12 * (x_g ** 2) * N1
            # Weighted contribution from current Gauss point
            weight = (x_e1 - x_e) / 2 * w
            b0 += weight * integrand_b0
            b1 += weight * integrand_b1
        
        # Accumulate local contributions into global right-hand side
        b[e, 0] += b0
        b[e+1, 0] += b1
    
    return A, b


------

Write a function adjust mass matrix A and right hand side vector b, adding Nitsche term and SUPG stabilization term.
Use following parameters:
- $s_{\kappa} = 1$
- $a = 200$
- $V_{\kappa} = Ch^{-1}(1+|s_{\kappa}|)$. 
- $C = 50$.
- $\tau = \frac{h}{2|a|}(coth(P^e)-\frac{1}{P^e})$, where $P^e = \frac{|a|h}{2\kappa}$ is the element Peclet number.
Background:

Then we need to deal with the assigned boundary condition and
stabilization term.
We use Nitsche method to weakly assign the boundary condition and the
Nitsche term also serve as a stabilization term.
\begin{equation}
\int_0^1\tau a \omega_{,x}(au_{,x}-\kappa u_{,xx} - 12x^2)dx
    + \omega(1)(au(1)-\kappa u_{,x}(1)) - s_{\kappa}\kappa\omega_{,x}(1)(u(1)-1) + V_{\kappa}\omega(1)(u(1)-1)
\end{equation}

With SUPG stabilization will be:
\begin{equation}
    \begin{aligned}
    \int_0^1 \omega_{,x}(-au+\kappa u_{,x})dx &- \int_0^1 12x^2\omega dx + \int_0^1\tau a \omega_{,x}(au_{,x}-\kappa u_{,xx} - 12x^2)dx\\
    &+ \omega(1)(au(1)-\kappa u_{,x}(1)) - s_{\kappa}\kappa\omega_{,x}(1)(u(1)-1) + V_{\kappa}\omega(1)(u(1)-1) = 0
    \end{aligned}
\end{equation}


def stabilization(A, b):
    '''Inputs:
    A : mass matrix, 2d array of shape (M,M)
    b : right hand side vector, 1d array of shape (M,)
    Outputs:
    A : mass matrix, 2d array of shape (M,M)
    b : right hand side vector 1d array of any size, 1d array of shape (M,)
    '''
    M = A.shape[0]
    # Ensure b is 1D
    if b.ndim == 2 and b.shape[1] == 1:
        b = b.flatten()
    
    if M == 1:
        return A, b
    
    # Parameters
    h = 1.0 / (M - 1)
    a = 2.0e2  # 200
    kappa = 1.0
    s_kappa = 1.0
    C = 50.0
    
    # Compute tau
    P_e = (abs(a) * h) / (2 * kappa)
    if P_e < 1e-10:
        # Use Taylor expansion to avoid numerical issues
        coth_Pe = 1.0 / P_e + P_e / 3.0
    else:
        coth_Pe = np.coth(P_e)
    tau = (h / (2 * abs(a))) * (coth_Pe - 1.0 / P_e)
    
    # Add SUPG stabilization terms to A
    supg_factor = tau * (a ** 2) / h
    for e in range(M - 1):
        A[e:e+2, e:e+2] += supg_factor * np.array([[1, -1], [-1, 1]], dtype=np.float64)
    
    # Add Nitsche terms to A
    V_kappa = C * (1 + abs(s_kappa)) / h
    # Term4: a * omega_i(1) * omega_j(1)
    A[M-1, M-1] += a
    # Term5: -kappa * omega_i(1) * omega_j,x(1)
    A[M-1, M-1] -= kappa / h
    # Term6: -s_kappa * kappa * omega_i,x(1) * omega_j(1)
    A[M-1, M-1] -= s_kappa * kappa / h
    # Term7: V_kappa * omega_i(1) * omega_j(1)
    A[M-1, M-1] += V_kappa
    
    # Compute additional terms for b
    term_b1 = np.zeros(M, dtype=np.float64)
    # Term b1: 12*a*tau * integral(omega_i,x * x² dx)
    term_b1[0] = 12 * a * tau * (-h ** 2 / 3.0)
    term_b1[M-1] = 12 * a * tau * (1.0 - h + (h ** 2) / 3.0)
    # Middle nodes (1 <= i <= M-2)
    if M > 2:
        i_mid = np.arange(1, M-1)
        term_b1[1:M-1] = 12 * a * tau * (-2 * i_mid * h ** 2)
    
    # Term b2: -s_kappa * kappa * omega_i,x(1)
    term_b2 = np.zeros(M, dtype=np.float64)
    term_b2[M-1] = -s_kappa * kappa / h
    
    # Term b3: V_kappa * omega_i(1)
    term_b3 = np.zeros(M, dtype=np.float64)
    term_b3[M-1] = V_kappa
    
    # Update b
    b += term_b1 + term_b2 + term_b3
    
    return A, b


NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Write a function to solve formed linear system using , and functions.

\begin{equation}
Ax = b
\end{equation}


def solve(N):
    '''Inputs: 
    N: number of element
    Outputs:
    sol: solution array, 1d array of size (N+1,)
    '''

    return sol

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

import numpy as np

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.