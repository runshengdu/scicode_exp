PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Construct the spatial differential operator a: Partial Derivative $\partial_i$. The first differential operator we want is a simple partial derivative: given an array of field values on 3d meshes, compute the partial derivates and return $\partial_x f(x,y,z)$, $\partial_y f(x,y,z)$ and $\partial_z f(x,y,z)$. We need a second order finite difference operator and on the boundary please use one-sided second-order expression.



def partial_derivs_vec(fct, delta):
    '''Computes the partial derivatives of a scalar field in three dimensions using second-order finite differences.
    Parameters:
    -----------
    fct : numpy.ndarray
        A 3D array representing the scalar field values on the grid. Shape: (nx, ny, nz).
    delta : float
        The grid spacing or step size in each spatial direction.
    Returns:
    --------
    deriv_x : numpy.ndarray
        The partial derivative of the field with respect to the x direction (∂f/∂x).
    deriv_y : numpy.ndarray
        The partial derivative of the field with respect to the y direction (∂f/∂y).
    deriv_z : numpy.ndarray
        The partial derivative of the field with respect to the z direction (∂f/∂z).
    '''
    nx, ny, nz = fct.shape
    
    # Initialize derivative arrays with the same shape as the input field
    deriv_x = np.zeros_like(fct)
    deriv_y = np.zeros_like(fct)
    deriv_z = np.zeros_like(fct)
    
    # Compute ∂f/∂x
    # Interior points using central second-order difference
    deriv_x[1:-1, :, :] = (fct[2:, :, :] - fct[:-2, :, :]) / (2 * delta)
    # Left boundary (x=0) using forward second-order difference
    deriv_x[0, :, :] = (-3 * fct[0, :, :] + 4 * fct[1, :, :] - fct[2, :, :]) / (2 * delta)
    # Right boundary (x=nx-1) using backward second-order difference
    deriv_x[-1, :, :] = (3 * fct[-1, :, :] - 4 * fct[-2, :, :] + fct[-3, :, :]) / (2 * delta)
    
    # Compute ∂f/∂y
    # Interior points using central second-order difference
    deriv_y[:, 1:-1, :] = (fct[:, 2:, :] - fct[:, :-2, :]) / (2 * delta)
    # Bottom boundary (y=0) using forward second-order difference
    deriv_y[:, 0, :] = (-3 * fct[:, 0, :] + 4 * fct[:, 1, :] - fct[:, 2, :]) / (2 * delta)
    # Top boundary (y=ny-1) using backward second-order difference
    deriv_y[:, -1, :] = (3 * fct[:, -1, :] - 4 * fct[:, -2, :] + fct[:, -3, :]) / (2 * delta)
    
    # Compute ∂f/∂z
    # Interior points using central second-order difference
    deriv_z[:, :, 1:-1] = (fct[:, :, 2:] - fct[:, :, :-2]) / (2 * delta)
    # Front boundary (z=0) using forward second-order difference
    deriv_z[:, :, 0] = (-3 * fct[:, :, 0] + 4 * fct[:, :, 1] - fct[:, :, 2]) / (2 * delta)
    # Back boundary (z=nz-1) using backward second-order difference
    deriv_z[:, :, -1] = (3 * fct[:, :, -1] - 4 * fct[:, :, -2] + fct[:, :, -3]) / (2 * delta)
    
    return deriv_x, deriv_y, deriv_z


------

Construct the spatial differential operator b: Laplacian $\nabla^2 = \partial_i \partial^i$. Take the laplacian calculation for a field on 3d meshes. Please implement the second order finite difference. Only output the value in the interior grids and make sure the output boundary values are zero.



def laplace(fct, delta):
    '''Computes the Laplacian of a scalar field in the interior of a 3D grid using second-order finite differences.
    This function calculates the Laplacian of a scalar field on a structured 3D grid using a central finite difference
    scheme. The output boundary values are set to zero to ensure the Laplacian is only calculated for the interior grid points.
    Parameters:
    -----------
    fct : numpy.ndarray
        A 3D array representing the scalar field values on the grid. Shape: (nx, ny, nz).
    delta : float
        The grid spacing or step size in each spatial direction.
    Returns:
    --------
    lap : numpy.ndarray
        A 3D array representing the Laplacian of the scalar field. Shape: (nx, ny, nz).
        The boundary values are set to zero, while the interior values are computed using the finite difference method.
    '''
    nx, ny, nz = fct.shape
    lap = np.zeros_like(fct)
    
    # Compute Laplacian for interior points (not on any boundary)
    lap[1:-1, 1:-1, 1:-1] = (
        # Second derivative in x-direction
        (fct[2:, 1:-1, 1:-1] - 2 * fct[1:-1, 1:-1, 1:-1] + fct[:-2, 1:-1, 1:-1]) +
        # Second derivative in y-direction
        (fct[1:-1, 2:, 1:-1] - 2 * fct[1:-1, 1:-1, 1:-1] + fct[1:-1, :-2, 1:-1]) +
        # Second derivative in z-direction
        (fct[1:-1, 1:-1, 2:] - 2 * fct[1:-1, 1:-1, 1:-1] + fct[1:-1, 1:-1, :-2])
    ) / (delta ** 2)
    
    return lap


------

Construct the spatial differential operator c: Gradient $\nabla_i f$ of Maxwell equations. Take the gradient calculation for a field on 3d meshes, that is calculate $\partial_x f, \partial_y f, \partial_z f$.  Please implement the second order finite difference. Only output the value in the interior grids and make sure the output boundary values are zero. Assume the grid length is the same in all dimensions.



def gradient(fct, delta):
    '''Computes the gradient of a scalar field in the interior of a 3D grid using second-order finite differences.
    This function calculates the gradient of a scalar field on a structured 3D grid using a central finite difference
    scheme. The output boundary values are set to zero to ensure the gradient is only calculated for the interior grid points.
    Parameters:
    -----------
    fct : numpy.ndarray
        A 3D array representing the scalar field values on the grid. Shape: (nx, ny, nz).
    delta : float
        The grid spacing or step size in all spatial directions.
    Returns:
    --------
    grad_x : numpy.ndarray
        The partial derivative of the field with respect to the x direction (∂f/∂x). 
        Shape: (nx, ny, nz). Boundary values are zeroed out.
    grad_y : numpy.ndarray
        The partial derivative of the field with respect to the y direction (∂f/∂y). 
        Shape: (nx, ny, nz). Boundary values are zeroed out.
    grad_z : numpy.ndarray
        The partial derivative of the field with respect to the z direction (∂f/∂z). 
        Shape: (nx, ny, nz). Boundary values are zeroed out.
    '''
    nx, ny, nz = fct.shape
    
    # Initialize gradient arrays with zeros
    grad_x = np.zeros_like(fct)
    grad_y = np.zeros_like(fct)
    grad_z = np.zeros_like(fct)
    
    # Compute ∂f/∂x for interior x points using central second-order difference
    grad_x[1:-1, :, :] = (fct[2:, :, :] - fct[:-2, :, :]) / (2 * delta)
    
    # Compute ∂f/∂y for interior y points using central second-order difference
    grad_y[:, 1:-1, :] = (fct[:, 2:, :] - fct[:, :-2, :]) / (2 * delta)
    
    # Compute ∂f/∂z for interior z points using central second-order difference
    grad_z[:, :, 1:-1] = (fct[:, :, 2:] - fct[:, :, :-2]) / (2 * delta)
    
    return grad_x, grad_y, grad_z


------

Construct the spatial differential operator d: Divergence $\nabla_i v^i$ of Maxwell equations. Please implement the second order finite difference for a vector fields on 3d meshes. Only output the value in the interior grids and make sure the output boundary values are zero. Assume the grid length is the same in all dimensions and take the grid length as a input in the function.



def divergence(v_x, v_y, v_z, delta):
    '''Computes the divergence of a 3D vector field using second-order finite differences.
    Parameters:
    -----------
    v_x : numpy.ndarray
        A 3D array representing the x-component of the vector field. Shape: (nx, ny, nz).
    v_y : numpy.ndarray
        A 3D array representing the y-component of the vector field. Shape: (nx, ny, nz).
    v_z : numpy.ndarray
        A 3D array representing the z-component of the vector field. Shape: (nx, ny, nz).
    delta : float
        The grid spacing or step size in all spatial directions.
    Returns:
    --------
    div : numpy.ndarray
        A 3D array representing the divergence of the vector field. Shape: (nx, ny, nz).
        The boundary values are set to zero.
    '''
    nx, ny, nz = v_x.shape
    div = np.zeros_like(v_x)
    
    # Compute divergence for interior grid points using central second-order differences
    div[1:-1, 1:-1, 1:-1] = (
        # Partial derivative of x-component with respect to x
        (v_x[2:, 1:-1, 1:-1] - v_x[:-2, 1:-1, 1:-1]) +
        # Partial derivative of y-component with respect to y
        (v_y[1:-1, 2:, 1:-1] - v_y[1:-1, :-2, 1:-1]) +
        # Partial derivative of z-component with respect to z
        (v_z[1:-1, 1:-1, 2:] - v_z[1:-1, 1:-1, :-2])
    ) / (2 * delta)
    
    return div


------

Construct the spatial differential operator e: Gradient of Divergence $\nabla_i (\nabla_j v^j)$. Please use the second order finite difference to calculate the gradient of the divergence of a vector fields. The fields are on a 3d mesh with the same grid length. Please note by first taking a divergence and then apply the gradient will result in larger error. Need to work out a finite difference formula for this operator.
Background

If we want to calculate the x gradient of divergence of vector field A then, we need to calculate 
$$
\partial_x (\partial_j A^j)  = \partial_x \partial_x A^x + \partial_x\partial_y A^{y} + \partial_x\partial_z A^z
$$
the first term is the second derivative of $A^x$, the last two terms are mixed second derivatives and can also be implemented in second order finite difference as 
$$
(\partial_x \partial_y A^y)_{ijk} = \frac{1}{4\Delta^2}(A^y_{i+1,j+1,k} - A^y_{i-1,j+1,k} - A^y_{i+1,j-1,k} + A^y_{i-1,j-1,k})
$$
with $\Delta$ denoting the grid length.



def grad_div(A_x, A_y, A_z, delta):
    '''Computes the gradient of the divergence of a 3D vector field using second-order finite differences.
    Parameters:
    -----------
    A_x : numpy.ndarray
        A 3D array representing the x-component of the vector field. Shape: (nx, ny, nz).
    A_y : numpy.ndarray
        A 3D array representing the y-component of the vector field. Shape: (nx, ny, nz).
    A_z : numpy.ndarray
        A 3D array representing the z-component of the vector field. Shape: (nx, ny, nz).
    delta : float
        The grid spacing or step size in all spatial directions.
    Returns:
    --------
    grad_div_x : numpy.ndarray
        A 3D array representing the x-component of the gradient of divergence. Shape: (nx, ny, nz).
        The boundary values are set to zero.
    grad_div_y : numpy.ndarray
        A 3D array representing the y-component of the gradient of divergence. Shape: (nx, ny, nz).
        The boundary values are set to zero.
    grad_div_z : numpy.ndarray
        A 3D array representing the z-component of the gradient of divergence. Shape: (nx, ny, nz).
        The boundary values are set to zero.
    '''
    nx, ny, nz = A_x.shape
    
    # Initialize gradient of divergence arrays with zeros
    grad_div_x = np.zeros_like(A_x)
    grad_div_y = np.zeros_like(A_y)
    grad_div_z = np.zeros_like(A_z)
    
    # Compute x-component of gradient of divergence (∂ₓ(∇·A)) in interior
    grad_div_x[1:-1, 1:-1, 1:-1] = (
        4 * (A_x[2:, 1:-1, 1:-1] - 2 * A_x[1:-1, 1:-1, 1:-1] + A_x[:-2, 1:-1, 1:-1]) +
        (A_y[2:, 2:, 1:-1] - A_y[:-2, 2:, 1:-1] - A_y[2:, :-2, 1:-1] + A_y[:-2, :-2, 1:-1]) +
        (A_z[2:, 1:-1, 2:] - A_z[:-2, 1:-1, 2:] - A_z[2:, 1:-1, :-2] + A_z[:-2, 1:-1, :-2])
    ) / (4 * delta ** 2)
    
    # Compute y-component of gradient of divergence (∂ᵧ(∇·A)) in interior
    grad_div_y[1:-1, 1:-1, 1:-1] = (
        (A_x[2:, 2:, 1:-1] - A_x[:-2, 2:, 1:-1] - A_x[2:, :-2, 1:-1] + A_x[:-2, :-2, 1:-1]) +
        4 * (A_y[1:-1, 2:, 1:-1] - 2 * A_y[1:-1, 1:-1, 1:-1] + A_y[1:-1, :-2, 1:-1]) +
        (A_z[1:-1, 2:, 2:] - A_z[1:-1, :-2, 2:] - A_z[1:-1, 2:, :-2] + A_z[1:-1, :-2, :-2])
    ) / (4 * delta ** 2)
    
    # Compute z-component of gradient of divergence (∂z(∇·A)) in interior
    grad_div_z[1:-1, 1:-1, 1:-1] = (
        (A_x[2:, 1:-1, 2:] - A_x[:-2, 1:-1, 2:] - A_x[2:, 1:-1, :-2] + A_x[:-2, 1:-1, :-2]) +
        (A_y[1:-1, 2:, 2:] - A_y[1:-1, :-2, 2:] - A_y[1:-1, 2:, :-2] + A_y[1:-1, :-2, :-2]) +
        4 * (A_z[1:-1, 1:-1, 2:] - 2 * A_z[1:-1, 1:-1, 1:-1] + A_z[1:-1, 1:-1, :-2])
    ) / (4 * delta ** 2)
    
    return grad_div_x, grad_div_y, grad_div_z


------

Construct Maxwell Fields Object. Please construct a Maxwell fields object that stores the evolving fields $E_x,E_y,E_z$, $A_x, A_y, A_z$ and $\phi$ as well as the cartesian coordinates the fields live on. The cartesian coordinates will be cell centered grids. Also, for future use, please also store the coordinate distance to the origin on each point. For simplicity, we only construct coordinates with $x>0, y>0$ and $z>0$ and reflect the fields in other octants in the final step. As a result, please construct an object that contains the mesh grid for the positive octant.


def __init__(self, n_grid, x_out):
    """Constructor sets up coordinates, memory for variables.
        The variables:
            mesh points:
                x: the x coordinate for each mesh grid
                y: the y coordinate for each mesh grid
                z: the z coordinate for each mesh grid
                t: the time coordinate of the simulation
                r: the distance to the origin for each mesh grid
            evolving fields:
                E_x: the x component of the field E
                E_y: the y componnet of the field E
                E_z: the z component of the field E
                A_x: the x component of the field A
                A_y: the y component of the field A
                A_z: the z component of the field A
                phi: the scalar potential field phi values
            monitor variables:
                constraint: the current constraint violation value from the evolving fields.
                
        """
    self.n_grid = n_grid
    self.n_vars = 7
    self.delta = float(x_out) / (n_grid - 2.0)
    delta = self.delta
    self.x = np.linspace(-self.delta * 0.5, x_out + 0.5 * self.delta, self.n_grid)[:, None, None]
    self.y = np.linspace(-self.delta * 0.5, x_out + 0.5 * self.delta, self.n_grid)[None, :, None]
    self.z = np.linspace(-self.delta * 0.5, x_out + 0.5 * self.delta, self.n_grid)[None, None, :]
    self.r = np.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)
    self.E_x = zeros((n_grid, n_grid, n_grid))
    self.E_y = zeros((n_grid, n_grid, n_grid))
    self.E_z = zeros((n_grid, n_grid, n_grid))
    self.A_x = zeros((n_grid, n_grid, n_grid))
    self.A_y = zeros((n_grid, n_grid, n_grid))
    self.A_z = zeros((n_grid, n_grid, n_grid))
    self.phi = zeros((n_grid, n_grid, n_grid))
    self.constraint = zeros((n_grid, n_grid, n_grid))
    self.t = 0.0

NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Please write a function that could apply the boundary condition for the derivatives. Since the calculation is done in the interior of the simulation octant and the mesh is cell centered, so please apply boundary condition for the inner boundary mesh grids (x=0,y=0,z=0) using the values in the interior of grid.


def symmetry(f_dot, x_sym, y_sym, z_sym):
    '''Computes time derivatives on inner boundaries from symmetry
    Parameters:
    -----------
    f_dot : numpy.ndarray
        A 3D array representing the time derivatives of the scalar field. Shape: (nx, ny, nz).
        This array will be updated in-place with symmetric boundary conditions applied.
    x_sym : float
        The symmetry factor to apply along the x-axis (typically -1 for antisymmetry, 1 for symmetry).
    y_sym : float
        The symmetry factor to apply along the y-axis (typically -1 for antisymmetry, 1 for symmetry).
    z_sym : float
        The symmetry factor to apply along the z-axis (typically -1 for antisymmetry, 1 for symmetry).
    Returns:
    --------
    f_dot : numpy.ndarray
        The same 3D array passed in as input, with updated values at the boundaries according to the symmetry conditions.
        Shape: (nx, ny, nz).
    '''

    return f_dot

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

from numpy import zeros, linspace, exp, sqrt
import numpy as np

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.