PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Given integers $j$ and $d$, write a function that returns a standard basis vector $|j\rangle$ in $d$-dimensional space. If $d$ is given as an int and $j$ is given as a list $[j_1,j_2\cdots,j_n]$, then return the tensor product $|j_1\rangle|j_2\rangle\cdots|j_n\rangle$ of $d$-dimensional basis vectors. If $d$ is also given as a list $[d_1,d_2,\cdots,d_n]$, return $|j_1\rangle|j_2\rangle\cdots|j_n\rangle$ as tensor product of $d_1$, $d_2$, ..., and $d_n$ dimensional basis vectors.
Background
A standard basis vector $|j\rangle$ in $d$ dimensional space is
\begin{pmatrix} 0 \\ 0 \\ \vdots \\ 1 \\ \vdots \\ 0 \end{pmatrix}
with a 1 on the $j$-th position and 0's everywhere else. Tensor products of two vectors are given by the Kronecker product 
\begin{align}
|a\rangle|b\rangle = \begin{pmatrix} a_1 \\ a_2 \\ \vdots \\ a_n \end{pmatrix} \otimes \begin{pmatrix} b_1 \\ b_2 \\ \vdots \\ b_n \end{pmatrix} = \begin{pmatrix} a_1b_1 \\ a_1b_2 \\ \vdots \\ a_1b_n \\ a_2b_1 \\ a_2b_2 \\ \vdots \\ a_2b_n \\ a_nb_1 \\ a_nb_2 \vdots \\ a_nb_n \end{pmatrix}
\end{align}



def ket(dim, j):
    '''Input:
    dim: int or list, dimension of the ket
    j: int or list, the i-th basis vector
    Output:
    out: dim dimensional array of float, the matrix representation of the ket
    '''
    if isinstance(j, int):
        if isinstance(dim, int):
            out = np.zeros(dim, dtype=float)
            out[j] = 1.0
        else:
            raise TypeError("When j is an integer, dim must be an integer")
    elif isinstance(j, list):
        if isinstance(dim, int):
            vectors = []
            for idx in j:
                vec = np.zeros(dim, dtype=float)
                vec[idx] = 1.0
                vectors.append(vec)
            out = vectors[0]
            for vec in vectors[1:]:
                out = np.kron(out, vec)
        elif isinstance(dim, list):
            if len(j) != len(dim):
                raise ValueError("Length of j must match length of dim when both are lists")
            vectors = []
            for idx, d in zip(j, dim):
                vec = np.zeros(d, dtype=float)
                vec[idx] = 1.0
                vectors.append(vec)
            out = vectors[0]
            for vec in vectors[1:]:
                out = np.kron(out, vec)
        else:
            raise TypeError("dim must be an integer or list of integers")
    else:
        raise TypeError("j must be an integer or list of integers")
    
    out = out.reshape(-1, 1)
    return out


------

Write a function that returns the tensor product of an arbitrary number of matrices/vectors.



def tensor(*args):
    '''Takes the tensor product of an arbitrary number of matrices/vectors.
    Input:
    args: any number of nd arrays of floats, corresponding to input matrices
    Output:
    M: the tensor product (kronecker product) of input matrices, 2d array of floats
    '''
    if len(args) == 0:
        return np.array([[1.0]], dtype=float)
    
    processed = []
    for arg in args:
        if not isinstance(arg, np.ndarray):
            raise TypeError("All inputs must be numpy ndarrays")
        if arg.ndim > 2:
            raise ValueError("Inputs must be 0D (scalars), 1D (vectors) or 2D (matrices)")
        
        if arg.ndim == 0:
            arg_2d = arg.reshape(1, 1)
        elif arg.ndim == 1:
            arg_2d = arg.reshape(-1, 1)
        else:
            arg_2d = arg
        
        processed.append(arg_2d.astype(float))
    
    result = processed[0]
    for mat in processed[1:]:
        result = np.kron(result, mat)
    
    return result


------

Write a function that applies the Kraus operators of a quantum channel on a subsystem of a state with tensor function. If sys and dim are given as None, then the channel acts on the entire system of the state rho. The dimension of each subsystem of the state is also given as an input.
Background
The action of quantum channels can be written in terms of its Kraus representation:
$$ \mathcal{N}(\rho) = \sum_i K_i \rho K_i^\dagger $$
where $\sum_i K_i^\dagger K_i = \mathbb{I}$. The $K_i$'s are called the Kraus operators of the channel $\mathcal{N}$. If the quantum channel acts on the $i$-th subsystem of $\rho$, then the Kraus operators has the form $\mathbb{I}\otimes\cdots\otimes\mathbb{I}\otimes K_i\otimes\mathbb{I}\otimes\cdots\otimes\mathbb{I}$, where $K_i$ acts on the $i$-th subsystem and the identity acts on the remaining systems.




------

Permute the subsystems of a state according to the order specified by perm given as a list. The dimensions of subsystems are given as a list of integers.




def syspermute(X, perm, dim):
    '''Permutes order of subsystems in the multipartite operator X.
    Inputs:
    X: 2d array of floats with equal dimensions, the density matrix of the state
    perm: list of int containing the desired order
    dim: list of int containing the dimensions of all subsystems.
    Output:
    Y: 2d array of floats with equal dimensions, the density matrix of the permuted state
    '''
    # Input validation
    if not isinstance(X, np.ndarray):
        raise TypeError("X must be a numpy ndarray")
    if X.ndim != 2:
        raise ValueError("X must be a 2D array")
    if X.shape[0] != X.shape[1]:
        raise ValueError("X must be a square matrix")
    
    n = len(dim)
    if len(perm) != n:
        raise ValueError(f"Length of perm ({len(perm)}) must match length of dim ({n})")
    if sorted(perm) != list(range(n)):
        raise ValueError(f"perm must be a valid permutation of 0 to {n-1} (inclusive)")
    
    total_dim = np.prod(dim)
    if X.shape != (total_dim, total_dim):
        raise ValueError(f"X's shape {X.shape} does not match total dimension {total_dim} from dim")
    
    # Convert to float to ensure output type correctness
    X_float = X.astype(float)
    
    # Reshape X into 2n-dimensional array (bra indices followed by ket indices)
    X_reshaped = X_float.reshape(dim + dim)
    
    # Create new axes order: permuted bra indices followed by permuted ket indices
    new_axes = perm + [n + p for p in perm]
    
    # Permute the axes to get the reshaped permuted state
    Y_reshaped = X_reshaped.transpose(new_axes)
    
    # Reshape back to 2D matrix
    Y = Y_reshaped.reshape(total_dim, total_dim)
    
    return Y


------

Calculate the partial trace of a state, tracing out a list of subsystems. Dimensions of all subsystems are given as inputs. Use the syspermute function.
Background
Suppose a state consists of two subsystems of dimension $d_1$ and $d_2$ and has the form 
$$
\begin{pmatrix}
A_{11} & A_{12} & \cdots & A_{1d_1} \\
A_{21} & A_{22} & \cdots & A_{2d_1} \\
\vdots & \vdots & \ddots & \vdots \\
A_{d_11} & A_{d_12} & \cdots & A_{d_1d_1}
\end{pmatrix}
$$
where each $A_{ij}$ is a $d_2\times d_2$ dimensional matrix. Then tracing out the second subsystem gives us
$$
\begin{pmatrix}
\text{tr}A_{11} & \text{tr}A_{12} & \cdots & \text{tr}A_{1d_1} \\
\text{tr}A_{21} & \text{tr}A_{22} & \cdots & \text{tr}A_{2d_1} \\
\vdots & \vdots & \ddots & \vdots \\
\text{tr}A_{d_11} & \text{tr}A_{d_12} & \cdots & \text{tr}A_{d_1d_1}
\end{pmatrix}
$$



def partial_trace(X, sys, dim):
    '''Inputs:
    X: 2d array of floats with equal dimensions, the density matrix of the state
    sys: list of int containing systems over which to take the partial trace (i.e., the systems to discard).
    dim: list of int containing dimensions of all subsystems.
    Output:
    2d array of floats with equal dimensions, density matrix after partial trace.
    '''
    # Input validation for X
    if not isinstance(X, np.ndarray):
        raise TypeError("X must be a numpy ndarray")
    if X.ndim != 2:
        raise ValueError("X must be a 2D array")
    if X.shape[0] != X.shape[1]:
        raise ValueError("X must be a square matrix")
    
    # Input validation for dim
    if not isinstance(dim, list):
        raise TypeError("dim must be a list of positive integers")
    for d in dim:
        if not isinstance(d, int) or d <= 0:
            raise ValueError(f"dim must contain positive integers, found {d}")
    n_subsystems = len(dim)
    
    # Input validation for sys
    if not isinstance(sys, list):
        raise TypeError("sys must be a list of integers")
    sys_set = set(sys)
    for s in sys:
        if not isinstance(s, int) or s < 0 or s >= n_subsystems:
            raise ValueError(f"Invalid subsystem index {s}: must be between 0 and {n_subsystems-1}")
    if len(sys_set) != len(sys):
        raise ValueError("sys contains duplicate subsystem indices")
    
    # Check X shape matches total dimension from dim
    total_dim = np.prod(dim, dtype=int)
    if X.shape != (total_dim, total_dim):
        raise ValueError(f"X's shape {X.shape} does not match total dimension {total_dim} from dim")
    
    # Convert X to float to ensure consistent output type
    X_float = X.astype(float)
    
    # Separate subsystems into keep and trace groups, preserving original order
    keep_sys = [s for s in range(n_subsystems) if s not in sys_set]
    trace_sys = [s for s in range(n_subsystems) if s in sys_set]
    
    # Create permutation to group keep subsystems first, then trace subsystems
    perm = keep_sys + trace_sys
    
    # Permute the state to group target subsystems
    X_perm = syspermute(X_float, perm, dim)
    
    # Calculate dimensions of keep and trace subsystems
    d_K = np.prod([dim[s] for s in keep_sys], dtype=int)
    d_T = np.prod([dim[s] for s in trace_sys], dtype=int)
    
    # Reshape permuted state into 4D array: (d_K, d_T, d_K, d_T)
    X_perm_reshaped = X_perm.reshape(d_K, d_T, d_K, d_T)
    
    # Compute partial trace by summing over matching trace indices in bra and ket
    partial_trace_result = np.einsum('acbc->ab', X_perm_reshaped)
    
    return partial_trace_result


NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Calculate the von Neumann entropy of a state


def entropy(rho):
    '''Inputs:
    rho: 2d array of floats with equal dimensions, the density matrix of the state
    Output:
    en: quantum (von Neumann) entropy of the state rho, float
    '''

    return en 

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

import numpy as np 
from scipy.optimize import fminbound
import itertools
from scipy.linalg import logm

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.