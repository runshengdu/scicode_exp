PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Write a Python function to generate a monolayer graphene geometry. Inputs are `s` sliding distance in the y-direction, `a` lattice constants, `z` z-coordinate, and `n` number of lattice sites to generate in negative and positive directions for both x and y axes. Make sure the armchair direction is along the y-axis and the zigzag direction is along the x-axis.




------

Write a Python function `assign_normals` to assign a normal vector for each atom. A normal vector at an atom is defined by averaging the 3 normalized cross products of vectors from this atom to its 3 nearest neighbors. Input is `xyzs` of shape `(natoms, 3)`. Return the normalized normal vectors of shape `(natoms,)`. Make sure that this vector is pointing in the negative z-direction for atoms with z > 0, and in the positive z-direction for atoms with z < 0. Correct normal vectors in the wrong direction by multiplying by -



def assign_normals(xyzs):
    '''Assign normal vectors on the given atoms
    Args:
        xyzs (np.array): Shape (natoms, 3)
    Returns:
        normed_cross_avg (np.array): Shape (natoms, 3)
    '''
    natoms = xyzs.shape[0]
    normals = np.zeros_like(xyzs)
    
    for i in range(natoms):
        pos = xyzs[i]
        # Compute vectors from current atom to all other atoms
        vectors = xyzs - pos
        # Calculate distances to all other atoms
        distances = la.norm(vectors, axis=1)
        # Get indices of the three nearest neighbors (excluding self)
        sorted_indices = np.argsort(distances)
        neighbor_indices = sorted_indices[1:4]
        neighbor_vectors = vectors[neighbor_indices]
        
        # Compute all three unique cross products between neighbor vectors
        cross1 = np.cross(neighbor_vectors[0], neighbor_vectors[1])
        cross2 = np.cross(neighbor_vectors[0], neighbor_vectors[2])
        cross3 = np.cross(neighbor_vectors[1], neighbor_vectors[2])
        
        # Normalize each cross product
        def normalize_vec(vec):
            norm = la.norm(vec)
            return vec / norm if norm > 1e-12 else np.zeros(3)
        
        norm_cross1 = normalize_vec(cross1)
        norm_cross2 = normalize_vec(cross2)
        norm_cross3 = normalize_vec(cross3)
        
        # Average the normalized cross products and re-normalize
        cross_avg = np.mean([norm_cross1, norm_cross2, norm_cross3], axis=0)
        avg_norm = la.norm(cross_avg)
        if avg_norm < 1e-12:
            # Fallback for degenerate cases (should not occur in graphene)
            initial_normal = np.array([0, 0, -1]) if pos[2] > 0 else np.array([0, 0, 1])
        else:
            initial_normal = cross_avg / avg_norm
        
        # Correct direction based on z-coordinate
        z_coord = pos[2]
        if z_coord > 0:
            # Ensure normal points in negative z-direction
            if initial_normal[2] > 0:
                initial_normal *= -1
        elif z_coord < 0:
            # Ensure normal points in positive z-direction
            if initial_normal[2] < 0:
                initial_normal *= -1
        
        normals[i] = initial_normal
    
    return normals


------

Write a Python function for replusive part of the total KC potential: $$V_{i j}=e^{-\lambda\left(r_{i j}-z_0\right)}\left[C+f\left(\rho_{i j}\right)+f\left(\rho_{j i}\right)\right]-A\left(\frac{r_{i j}}{z_0}\right)^{-6}$$ Inputs are distance vectors from atom i to atom j `r_ij` of shape (npairs, 3), normal vectors of the top layer `n_i`, normal vectors of the bottom layer `n_j`, and the following KC parameters `z0`, `C`, `C0`, `C2`, `C4`, `delta`, `lamda`. The transverse distance `rho` is defined as 

\begin{align}
\rho_{ij}^2 &= r_{ij}^2 - (\mathbf{r}_{ij} \cdot \mathbf{n}_i)^2. \nonumber \\
\rho_{ji}^2 &= r_{ij}^2 - (\mathbf{r}_{ij} \cdot \mathbf{n}_j)^2. \nonumber \\
\end{align}

and

\begin{align}
f(\rho) &= e^{-(\rho/\delta)^2} \left[ C_0  + C_2 \left(\frac{\rho}{\delta}\right)^{2} + C_4 \left(\frac{\rho}{\delta}\right)^{4}\right]
\end{align}
Background

The repulsive part of KC potential:
\begin{align}
V_{ij} = e^{-\lambda(r_{ij} - z_0)} [C + f(\rho_{ij}) + f(\rho_{ji})] 
\end{align}


def potential_repulsive(r_ij, n_i, n_j, z0, C, C0, C2, C4, delta, lamda):
    '''Define repulsive potential.
    Args:
        r_ij: (nmask, 3)
        n_i: (nmask, 3)
        n_j: (nmask, 3)
        z0 (float): KC parameter
        C (float): KC parameter
        C0 (float): KC parameter
        C2 (float): KC parameter
        C4 (float): KC parameter
        delta (float): KC parameter
        lamda (float): KC parameter
    Returns:
        pot (nmask): values of repulsive potential for the given atom pairs.
    '''
    # Compute distance between atom pairs
    r = la.norm(r_ij, axis=1)
    # Exponential term in the repulsive potential
    exp_term = np.exp(-lamda * (r - z0))
    
    # Squared distance for rho calculations
    r_sq = r ** 2
    
    # Dot products of r_ij with normal vectors n_i and n_j
    dot_i = (r_ij * n_i).sum(axis=1)
    dot_j = (r_ij * n_j).sum(axis=1)
    
    # Compute squared rho values and clamp to non-negative to avoid numerical issues
    rho_ij_sq = r_sq - dot_i ** 2
    rho_ij_sq = np.maximum(rho_ij_sq, 0.0)
    
    rho_ji_sq = r_sq - dot_j ** 2
    rho_ji_sq = np.maximum(rho_ji_sq, 0.0)
    
    # Calculate x terms (rho/delta)^2 to avoid square roots
    delta_sq = delta ** 2
    x_ij = rho_ij_sq / delta_sq
    x_ji = rho_ji_sq / delta_sq
    
    # Compute f(rho_ij) and f(rho_ji)
    f_ij = np.exp(-x_ij) * (C0 + C2 * x_ij + C4 * (x_ij ** 2))
    f_ji = np.exp(-x_ji) * (C0 + C2 * x_ji + C4 * (x_ji ** 2))
    
    # Combine terms for the repulsive potential
    bracket_term = C + f_ij + f_ji
    pot = exp_term * bracket_term
    
    return pot


NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Write a Python function for the attractive part of the total KC potential:

$$V_{i j}=e^{-\lambda\left(r_{i j}-z_0\right)}\left[C+f\left(\rho_{i j}\right)+f\left(\rho_{j i}\right)\right]-A\left(\frac{r_{i j}}{z_0}\right)^{-6}$$
Background

The attractive part of $V_{ij}$ is 

\begin{align}
V_{ij} = - A\left(\frac{r_{ij}}{z_0}\right)^{-6}
\end{align}

def potential_attractive(rnorm, z0, A):
    '''Define attractive potential.
    Args:
        rnorm (float or np.array): distance
        z0 (float): KC parameter
        A (float): KC parameter
    Returns:
        pot (float): calculated potential
    '''

    return pot

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

import numpy as np
import numpy.linalg as la

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.