PROBLEM DESCRIPTION:
You will be provided with problem steps along with background knowledge necessary for solving the problem. Your task will be to develop a Python solution focused on the next step of the problem-solving process.

PROBLEM STEPS AND FUNCTION CODE:
Here, you'll find the Python code for the initial steps of the problem-solving process. This code is integral to building the solution.

Write a function that returns the tensor product of an arbitrary number of matrices/vectors.



def tensor(*args):
    '''Takes the tensor product of an arbitrary number of matrices/vectors.
    Input:
    args: any number of nd arrays of floats, corresponding to input matrices
    Output:
    M: the tensor product (kronecker product) of input matrices, 2d array of floats
    '''
    if not args:
        raise ValueError("At least one matrix or vector must be provided.")
    
    processed_arrays = []
    for arg in args:
        arr = np.asarray(arg)
        if arr.ndim == 1:
            # Convert 1D vector to 2D column vector
            arr = arr.reshape(-1, 1)
        elif arr.ndim != 2:
            raise ValueError("All inputs must be 1D (vectors) or 2D (matrices).")
        processed_arrays.append(arr)
    
    # Compute successive Kronecker products
    result = processed_arrays[0]
    for mat in processed_arrays[1:]:
        result = np.kron(result, mat)
    
    return result


------

Write a function that applies the Kraus operators of a quantum channel on subsystems of a state with tensor function. If sys and dim are given as None, then the channel acts on the entire system of the state rho. If sys is given as a list, then the channel is applied to each subsystem in that list, and the dimension of each subsystem also must be given.
Background
The action of quantum channels can be written in terms of its Kraus representation:
$$ \mathcal{N}(\rho) = \sum_i K_i \rho K_i^\dagger $$
where $\sum_i K_i^\dagger K_i = \mathbb{I}$. The $K_i$'s are called the Kraus operators of the channel $\mathcal{N}$. If the quantum channel acts on the $i$-th subsystem of $\rho$, then the Kraus operators has the form $\mathbb{I}\otimes\cdots\otimes\mathbb{I}\otimes K_i\otimes\mathbb{I}\otimes\cdots\otimes\mathbb{I}$, where $K_i$ acts on the $i$-th subsystem and the identity acts on the remaining systems.


def apply_channel(K, rho, sys=None, dim=None):
    '''Applies the channel with Kraus operators in K to the state rho on
    systems specified by the list sys. The dimensions of the subsystems of
    rho are given by dim.
    Inputs:
    K: list of 2d array of floats, list of Kraus operators
    rho: 2d array of floats, input density matrix
    sys: list of int or None, list of subsystems to apply the channel, None means full system
    dim: list of int or None, list of dimensions of each subsystem, None means full system
    Output:
    matrix: output density matrix of floats
    '''
    # Convert rho to numpy array and validate
    rho = np.asarray(rho)
    if rho.ndim != 2 or rho.shape[0] != rho.shape[1]:
        raise ValueError("rho must be a square 2D array (density matrix).")
    
    # Validate Kraus operators
    if not isinstance(K, list) or len(K) == 0:
        raise ValueError("K must be a non-empty list of Kraus operators.")
    k_shapes = set()
    for k in K:
        k_arr = np.asarray(k)
        if k_arr.ndim != 2 or k_arr.shape[0] != k_arr.shape[1]:
            raise ValueError(f"Kraus operator {k} must be a square 2D matrix.")
        k_shapes.add(k_arr.shape)
    if len(k_shapes) != 1:
        raise ValueError("All Kraus operators must have the same shape.")
    k_dim = k_shapes.pop()[0]
    
    # Handle different cases for sys and dim
    if sys is None and dim is None:
        # Apply channel to entire system
        d = rho.shape[0]
        if k_dim != d:
            raise ValueError(f"Kraus operators are {k_dim}x{k_dim}, but rho is {d}x{d}.")
        result = np.zeros_like(rho)
        for k in K:
            k_arr = np.asarray(k)
            result += k_arr @ rho @ k_arr.conj().T
        return result
    elif isinstance(sys, list) and isinstance(dim, list):
        # Apply channel to specified subsystems
        # Validate dim
        if len(dim) == 0:
            raise ValueError("dim must be a non-empty list of subsystem dimensions.")
        for d in dim:
            if not isinstance(d, int) or d <= 0:
                raise ValueError(f"Subsystem dimension {d} must be a positive integer.")
        total_dim = np.prod(dim)
        if rho.shape[0] != total_dim:
            raise ValueError(f"rho is {rho.shape[0]}x{rho.shape[0]}, but product of dim is {total_dim}.")
        
        # Validate sys
        sys_set = set()
        for s in sys:
            if not isinstance(s, int):
                raise ValueError(f"Subsystem index {s} must be an integer.")
            if s < 0 or s >= len(dim):
                raise ValueError(f"Subsystem index {s} is out of range (0 to {len(dim)-1}).")
            if s in sys_set:
                raise ValueError(f"Subsystem index {s} is duplicated in sys.")
            sys_set.add(s)
            if dim[s] != k_dim:
                raise ValueError(f"Subsystem {s} has dimension {dim[s]}, but Kraus operators are {k_dim}x{k_dim}.")
        
        # Precompute identity matrices for each subsystem
        identities = [np.eye(d, dtype=rho.dtype) for d in dim]
        # Map subsystem indices to their positions in the sys list
        sys_to_tuple_idx = {s: i for i, s in enumerate(sys)}
        
        result = np.zeros_like(rho)
        # Iterate over all combinations of Kraus operators for target subsystems
        for tuple_k in itertools.product(K, repeat=len(sys)):
            op_list = []
            for s in range(len(dim)):
                if s in sys_to_tuple_idx:
                    # Get the corresponding Kraus operator from the tuple
                    k = tuple_k[sys_to_tuple_idx[s]]
                    k_arr = np.asarray(k)
                    op_list.append(k_arr)
                else:
                    # Use identity matrix for non-target subsystems
                    op_list.append(identities[s])
            # Compute combined Kraus operator using tensor product
            combined_k = tensor(*op_list)
            # Apply the combined Kraus operator to rho
            result += combined_k @ rho @ combined_k.conj().T
        return result
    else:
        # Invalid combination of sys and dim
        raise ValueError("Either both sys and dim are None, or sys is a list and dim is a list.")


NEXT STEP - PROBLEM STEP AND FUNCTION HEADER:
This part will describe the next step in the problem-solving process. A function header will be provided, and your task is to develop the Python code for this next step based on the provided description and function header.

Given a 2n-qubit input state and the Kraus operators of two qubit channels channel1 and channel2, we send the first n qubits through n uses of channel1 and the last n qubits through n uses of channel2. Implement a function that returns the output state using the apply_channel function in . Here, channel2 is set to None in default, and if channel2 is None, it is set to be equal to channel1.


def channel_output(input_state, channel1, channel2=None):
    '''Returns the channel output
    Inputs:
        input_state: density matrix of the input 2n qubit state, ( 2**(2n), 2**(2n) ) array of floats
        channel1: kruas operators of the first channel, list of (2,2) array of floats
        channel2: kruas operators of the second channel, list of (2,2) array of floats
    Output:
        output: the channel output, ( 2**(2n), 2**(2n) ) array of floats
    '''

    return output

DEPENDENCIES:
Use only the following dependencies in your solution. Do not include these dependencies at the beginning of your code.

import numpy as np
from scipy.linalg import sqrtm
import itertools

RESPONSE GUIDELINES:
Now, based on the instructions and information provided above, write the complete and executable Python program for the next step in a single block.
Your response should focus exclusively on implementing the solution for the next step, adhering closely to the specified function header and the context provided by the initial steps.
Your response should NOT include the dependencies and functions of all previous steps. If your next step function calls functions from previous steps, please make sure it uses the headers provided without modification.
DO NOT generate EXAMPLE USAGE OR TEST CODE in your response. Please make sure your response python code in format of ```python```.